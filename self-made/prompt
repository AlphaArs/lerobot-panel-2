I'm trying to make a good prompt can you help me make it clear:

I'm trying to create a all in one project in a single repo, where I have electron to bind everything together, a nextjs frontend, the huggingface lerobot project and then a fastapi backend.

I want all of this to work together to easely have control over the lerobot project. the first thing I would like to do is having a setup process where we can add a robot, and then it asks us to plug in the robot (also accept the plug out and plug in again) to identify which usb device it is. then next we see a list of possible robot model we might add multiple types late but for now we only have the so101 once we selected the type we need to select wether the robot is a leader or folower arm. Then next we can give it a name.

once this is done we can go on the robots page where we see all robots we added. we also see the status of the arm online or offline wether its plugged in or plugged out. and thus detected or not. you can then click on the bot this brings us on a page or modal and somewhere there should be an option to calibrate it. if there already is an existing calibration it should show a popup asking if we want to override the existing calibration. if we do not have an existing one we directly go do the calibration page. There we should get an explanation to place the bot in neutral position with a start button so that we can start calibration once we've set the bot in neurtral position.

then we see for each joint the min value, current value and max value.

once we have done all movements and think we are done we can press on the End button.

now once a calibratrion has been made on a leader arm we also have a teleoperate custom dropdown where we can see all folower arms of the same style. if you select one that has not been calibrated yet, you then get a popup telling you the bot needs to be calibrated before being able to teleoperate. if you select one that has a calibration you then need to press the teleoperate button next to the dropdown to show a modal or dropdown, telling you to set the arms more or less in the same position to avoid any damage. with a start button that the user can press once he's done.

then we actually start the teleoperation. on the ui you see that you are curently controlling the robot, but you also need a button to stop the action.

I do want a way to delete the bots but I do also want it to delete the calibration data when I delete the bot.

I do want to have a the way I want to detect the devices do use the com. I made a script that works to detect devices: """
Watch for USB devices that connect or disconnect after the script starts.

The script takes a snapshot of currently present USB devices and then reports
only changes (connections/disconnections) that happen afterwards.
Requires PowerShell and the Get-PnpDevice cmdlet (available on Windows 10+).
"""

import json
import subprocess
import sys
import time

POLL_SECONDS = 1.0

def fetch*usb_devices():
"""Return a dict mapping instance id -> friendly name for present USB devices."""
ps_command = (
"[Console]::OutputEncoding = [System.Text.Encoding]::UTF8; "
"@(Get-PnpDevice -PresentOnly "
"| Where-Object { $*.InstanceId -like 'USB\*' } "
"| Select-Object InstanceId, FriendlyName)"
" | ConvertTo-Json -Depth 2"
)

    # Use bytes + manual decode to avoid UnicodeDecodeError on localized consoles.
    result = subprocess.run(
        ["powershell", "-NoLogo", "-NoProfile", "-Command", ps_command],
        capture_output=True,
        text=False,
    )

    if result.returncode != 0:
        stderr_text = (result.stderr or b"").decode("utf-8", errors="replace").strip()
        raise RuntimeError(stderr_text or "PowerShell command failed")

    output = (result.stdout or b"").decode("utf-8", errors="replace").strip() or "[]"
    data = json.loads(output)

    if isinstance(data, dict):  # Convert single-object JSON to a list for uniformity.
        data = [data]

    devices = {}
    for item in data:
        instance_id = item.get("InstanceId")
        if not instance_id:
            continue
        friendly = item.get("FriendlyName") or "(unknown USB device)"
        devices[instance_id] = friendly

    return devices

def main():
print("Monitoring USB devices... (press Ctrl+C to stop)")
baseline = fetch_usb_devices()
print(f"Ignoring {len(baseline)} device(s) already present.")
previous = baseline

    try:
        while True:
            time.sleep(POLL_SECONDS)
            try:
                current = fetch_usb_devices()
            except Exception as exc:  # Keep running even if a read fails.
                print(f"Error reading USB devices: {exc}", file=sys.stderr)
                continue

            added = current.keys() - previous.keys()
            removed = previous.keys() - current.keys()

            for instance_id in sorted(added):
                print(f"[connected] {current[instance_id]} ({instance_id})")

            for instance_id in sorted(removed):
                name = previous.get(instance_id, "(unknown USB device)")
                print(f"[disconnected] {name} ({instance_id})")

            previous = current
    except KeyboardInterrupt:
        print("\nStopped.")

if **name** == "**main**":
main()

and also for comunication, like for example for when to start the calibration this worked, but do use the name, robot model and type and com when executing the command. Those are given by the robot since we have the name, model (so101) and type (leader or follower):

#!/usr/bin/env python
"""
Prompt for COM port, device name, and SO101 type, then run the matching
`lerobot-calibrate` command using the current Python interpreter.

The script adds the local `lerobot/src` to PYTHONPATH so it works with a
checkout of the repo as well as an installed package.
"""

from **future** import annotations

import os
import shlex
import subprocess
import sys
from pathlib import Path
from typing import Callable

SUPPORTED_TYPES = {
"so101_follower": "robot",
"so101_leader": "teleop",
}

def prompt(label: str, \*, default: str | None = None, validator: Callable[[str], bool] | None = None) -> str:
while True:
suffix = f" [{default}]" if default else ""
value = input(f"{label}{suffix}: ").strip()
if not value:
if default is not None:
return default
print("Please enter a value.")
continue
if validator and not validator(value):
print("Invalid value, try again.")
continue
return value

def choose_type() -> str:
options = list(SUPPORTED_TYPES.keys())
return choose_from_menu("Device type", options, default_index=0)

def choose_from_menu(
label: str, options: list[str], \*, default_index: int = 0, allow_manual: bool = False
) -> str:
print(f"{label}:")
for idx, option in enumerate(options, start=1):
default_marker = " (default)" if idx - 1 == default_index else ""
print(f" {idx}. {option}{default_marker}")

    prompt_text = "Enter number"
    if allow_manual:
        prompt_text += " or type a value"
    prompt_text += " (blank for default): "

    while True:
        choice = input(prompt_text).strip()
        if not choice:
            return options[default_index]
        if choice.isdigit():
            idx = int(choice) - 1
            if 0 <= idx < len(options):
                return options[idx]
        if allow_manual:
            return choice
        print("Invalid selection, try again.")

def detect_com_ports() -> list[tuple[str, str]]:
"""
Try to list COM ports via pyserial; falls back to empty list if unavailable.
Returns a list of (device, description).
"""
try:
from serial.tools import list_ports
except Exception:
return []

    ports = []
    for info in list_ports.comports():
        device = info.device
        desc = info.description or device
        if device:
            ports.append((device, desc))
    return ports

def choose_port() -> str:
ports = detect_com_ports()
if ports:
menu_entries = [
f"{device} ({desc})" if desc and desc != device else device for device, desc in ports
]
selected = choose_from_menu("COM port", menu_entries, default_index=0, allow_manual=True) # If the user picked an entry from the menu, map back to the device value.
for device, desc in ports:
if selected == f"{device} ({desc})" or selected == device:
return device
return selected

    print("No COM ports detected automatically; type one manually (e.g. COM14).")
    return prompt("COM port")

def build_command(device_type: str, port: str, name: str) -> list[str]:
role = SUPPORTED_TYPES[device_type]
return [
sys.executable,
"-m",
"lerobot.scripts.lerobot_calibrate",
f"--{role}.type={device_type}",
f"--{role}.port={port}",
f"--{role}.id={name}",
]

def add_repo_to_env(env: dict[str, str]) -> tuple[dict[str, str], Path | None]:
repo_src = Path(**file**).resolve().parent / "lerobot" / "src"
if repo_src.exists():
env = env.copy()
existing = env.get("PYTHONPATH", "")
env["PYTHONPATH"] = f"{repo_src}{os.pathsep}{existing}" if existing else str(repo_src)
return env, repo_src.parent
return env, None

def main() -> int:
device_type = choose_type()
port = choose_port()
name = prompt("Device name", default=device_type)

    cmd = build_command(device_type, port, name)
    env, repo_root = add_repo_to_env(os.environ)
    cwd = repo_root if repo_root else Path.cwd()

    readable_cmd = subprocess.list2cmdline(cmd) if os.name == "nt" else " ".join(shlex.quote(c) for c in cmd)
    print(f"\nExecuting: {readable_cmd}\n")

    try:
        result = subprocess.run(cmd, env=env, cwd=cwd)
    except KeyboardInterrupt:
        print("\nCancelled.")
        return 130
    return result.returncode

if **name** == "**main**":
raise SystemExit(main())

here are example commands:

lerobot-calibrate --robot.type=so101_follower --robot.port=COM13 --robot.id=follower_arm

lerobot-calibrate --teleop.type=so101_leader --teleop.port=COM14 --teleop.id=leader_arm

as you see the teleop type changes in function of model and type.

Ideally I would like to work with websockets to get live logs, and maybe also the live status of the bot (online / offline)

when calibrating the bot reports this constantly
NAME | MIN | POS | MAX
shoulder_pan | 2038 | 2043 | 2047
shoulder_lift | 2044 | 2046 | 2047
elbow_flex | 2046 | 2046 | 2047
wrist_flex | 2047 | 2053 | 2056
wrist_roll | 2038 | 2042 | 2047
gripper | 2028 | 2036 | 3270

---

with the values updating. I would like to show this live updating on the frontent ui, also show the range of movement as extra info.

for now this is what I want

